import OpenAI from 'openai';

export class OpenAIService {
    private client: OpenAI;

    constructor(apiKey: string) {
        this.client = new OpenAI({
            apiKey: apiKey
        });
    }

    async generateParser(url: string, htmlText: string): Promise<string> {
        const prompt = this.createParserPrompt(url, htmlText);

        try {
            const completion = await this.client.chat.completions.create({
                model: "gpt-4",
                messages: [
                    {
                        role: "system",
                        content: "You are an expert at creating HTML parsers. Generate clean, efficient JavaScript/TypeScript code that extracts relevant content from HTML."
                    },
                    {
                        role: "user",
                        content: prompt
                    }
                ],
                temperature: 0.1,
                max_tokens: 2000
            });

            const parserCode = completion.choices[0]?.message?.content;
            if (!parserCode) {
                throw new Error('No parser code generated by OpenAI');
            }

            return this.sanitizeParserCode(parserCode);
        } catch (error) {
            console.error('Error generating parser with OpenAI:', error);
            throw new Error(`Failed to generate parser: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }

    private createParserPrompt(url: string, htmlText: string): string {
        return `
Create a JavaScript function that parses HTML content from the following URL pattern and extracts relevant text content.

URL: ${url}

Sample HTML content (first 2000 characters):
${htmlText.substring(0, 2000)}

Requirements:
1. The function should be named 'parseHtml' and accept a $ argument which is equivalent to cheerio.load(html).
2. Extract only relevant text content, ignoring navigation, ads, scripts, styles, and other non-content elements
3. Use selectors as specific as possible to retrieve the most relevant text content, excluding irrelevant text content next to it
3. Return a clean object with extracted data
4. Use modern JavaScript syntax
5. Include proper error handling but do not swallow errors. If the parser encountered something unexpected, throw an error.
6. The function should be self-contained and not require external dependencies beyond the cheerio instance passed in as a parameter.

Return only the function code, no explanations or markdown formatting. No comments at all. Only the function definition matters.
        `.trim();
    }

    private sanitizeParserCode(code: string): string {
        const codeBlockRegex = /```(?:javascript|js|typescript|ts)?\s*\n([\s\S]*?)\n```/;
        const match = code.match(codeBlockRegex);

        let runnableFunction = match && match[1] ? match[1].trim() : code.trim();
        
        if (runnableFunction.startsWith('function')) {
            const functionBodyRegex = /function\s+\w+\s*\([^)]*\)\s*\{([\s\S]*)\}/;
            const bodyMatch = runnableFunction.match(functionBodyRegex);
            
            if (bodyMatch && bodyMatch[1]) {
                // Return the function body content
                return bodyMatch[1].trim();
            }
        }
        
        // Handle arrow functions
        if (runnableFunction.includes('=>')) {
            const arrowFunctionRegex = /(?:const|let|var)?\s*\w+\s*=\s*\([^)]*\)\s*=>\s*\{([\s\S]*)\}/;
            const arrowMatch = runnableFunction.match(arrowFunctionRegex);
            
            if (arrowMatch && arrowMatch[1]) {
                return arrowMatch[1].trim();
            }
        }

        return runnableFunction;
    }
}
