import OpenAI from 'openai';
import { logger, getErrorInfo } from '../utils/logger';
import { preprocessHtmlForOpenAI } from '../utils/htmlExtractor';
import { ParserGenerator } from '../types';
import { countRequestTokens, countTokens } from '../utils/tokenCounter';
import { TiktokenModel } from 'tiktoken';
import { Stats } from '../utils/stats';

const MODEL: TiktokenModel = 'gpt-4';

export class OpenAIService implements ParserGenerator {
    private client: OpenAI;
    private stats: Stats;

    constructor(apiKey: string) {
        this.client = new OpenAI({
            apiKey,
        });
        this.stats = new Stats();
    }

    async generateParser(url: string, htmlText: string): Promise<string> {
        const prompt = await this.createParserPrompt(url, htmlText);

        const messages: Array<{ role: 'system' | 'user'; content: string }> = [
            {
                role: 'system',
                content:
                    'You are an expert at creating HTML parsers. Generate clean, efficient JavaScript code that extracts relevant content from HTML.',
            },
            {
                role: 'user',
                content: prompt,
            },
        ];

        const inputTokens = countRequestTokens(messages, MODEL);

        try {
            const completion = await this.client.chat.completions.create({
                model: MODEL,
                messages,
                temperature: 0.1,
                max_completion_tokens: 2000,
            });

            const parserCode = completion.choices[0]?.message?.content;
            if (!parserCode) {
                throw new Error('No parser code generated by OpenAI');
            }

            const outputTokens = countTokens(parserCode, MODEL);
            const totalTokens = inputTokens + outputTokens;

            this.stats.addRequest(inputTokens, outputTokens);

            logger.info('OpenAI parser generation token count', {
                inputTokens,
                outputTokens,
                totalTokens,
                url,
            });

            return this.sanitizeParserCode(parserCode);
        } catch (error) {
            logger.error('Error generating parser with OpenAI:', getErrorInfo(error));
            throw new Error(
                `Failed to generate parser: ${error instanceof Error ? error.message : 'Unknown error'}`
            );
        }
    }

    private async createParserPrompt(url: string, htmlText: string): Promise<string> {
        const processedHtml = await preprocessHtmlForOpenAI(htmlText);

        return `
Create a JavaScript function that parses HTML content from the following URL pattern and extracts relevant text content.

URL: ${url}

HTML Structure Analysis:
\`\`\`html
${processedHtml}
\`\`\`

Requirements:
1. The function should be named 'parseHtml' and accept a $ argument which is equivalent to cheerio.load(html).
2. Extract only relevant text content, ignoring navigation, ads, scripts, styles, and other non-content elements
3. Use selectors as specific as possible to retrieve the most relevant text content, excluding irrelevant text content next to it
4. Return a clean object with extracted data
5. Use modern JavaScript syntax
6. Include proper error handling but do not swallow errors. If the parser encountered something unexpected, throw an error.
7. The function should be self-contained and not require external dependencies beyond the cheerio instance passed in as a parameter.

Return only the function code, no explanations or markdown formatting. No comments at all. Only the function definition matters.
        `.trim();
    }

    private sanitizeParserCode(code: string): string {
        const codeBlockRegex = /```(?:javascript|js|typescript|ts)?\s*\n([\s\S]*?)\n```/;
        const match = code.match(codeBlockRegex);

        const runnableFunction = match && match[1] ? match[1].trim() : code.trim();

        if (runnableFunction.startsWith('function')) {
            const functionBodyRegex = /function\s+\w+\s*\([^)]*\)\s*\{([\s\S]*)\}/;
            const bodyMatch = runnableFunction.match(functionBodyRegex);

            if (bodyMatch && bodyMatch[1]) {
                return bodyMatch[1].trim();
            }
        }

        if (runnableFunction.includes('=>')) {
            const arrowFunctionRegex =
                /(?:const|let|var)?\s*\w+\s*=\s*\([^)]*\)\s*=>\s*\{([\s\S]*)\}/;
            const arrowMatch = runnableFunction.match(arrowFunctionRegex);

            if (arrowMatch && arrowMatch[1]) {
                return arrowMatch[1].trim();
            }
        }

        return runnableFunction;
    }

    getStats() {
        return this.stats.getStats();
    }
}
